#[cfg(not(feature = "std"))]
use alloc::{
    format,
    string::{String, ToString},
    vec,
    vec::Vec,
};
use core::{convert, fmt, str};

use hmac::Hmac;
use sha2::{Digest, Sha256, Sha512};
use unicode_normalization::UnicodeNormalization;

use crate::error::Error;
use crate::language::Language;
use crate::util::{bits11_to_index, left_bit_mask};

const ENTROPY_OFFSET: usize = 8;
const BITS_PER_WORD: usize = 11;

/// Determines the number of words that will be present in a [`Mnemonic`] phrase.
///
/// First, an initial entropy of ENT bits is generated.
/// A checksum is generated by taking the first `ENT/32` bits of its SHA256 hash.
/// This checksum is appended to the end of the initial entropy.
///
/// Next, these concatenated bits are split into groups of `11` bits,
/// each encoding a number from 0-2047, serving as an index into a wordlist.
///
/// Finally, we convert these numbers into words and use the joined words as a mnemonic sentence.
///
/// - **ENT**: the initial entropy length
/// - **CS**: the checksum length
/// - **MS**: the length of the generated mnemonic sentence in words
///
/// **CS** = **ENT** / 32
///
/// **MS** = (**ENT** + **CS**) / 11
///
/// |  ENT  |  CS  | ENT+CS |  MS  |
/// | :---: | :--: | :----: | :--: |
/// |  128  |  4   |  132   |  12  |
/// |  160  |  5   |  165   |  15  |
/// |  192  |  6   |  198   |  18  |
/// |  224  |  7   |  231   |  21  |
/// |  256  |  8   |  264   |  24  |
///
/// For example, a 12 word mnemonic phrase is essentially a friendly representation of
/// a 128-bit key, while a 24 word mnemonic phrase is essentially a 256-bit key.
///
#[derive(Copy, Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub enum MnemonicWordCount {
    /// 12 words, entropy length: 128 bits, the checksum length: 4 bits.
    Words12 = (128 << ENTROPY_OFFSET) | 4,
    /// 15 words, entropy length: 160 bits, the checksum length: 5 bits.
    Words15 = (160 << ENTROPY_OFFSET) | 5,
    /// 18 words, entropy length: 192 bits, the checksum length: 6 bits.
    Words18 = (192 << ENTROPY_OFFSET) | 6,
    /// 21 words, entropy length: 224 bits, the checksum length: 7 bits.
    Words21 = (224 << ENTROPY_OFFSET) | 7,
    /// 24 words, entropy length: 256 bits, the checksum length: 8 bits.
    Words24 = (256 << ENTROPY_OFFSET) | 8,
}

impl Default for MnemonicWordCount {
    fn default() -> Self {
        Self::Words12
    }
}

impl fmt::Display for MnemonicWordCount {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{} words (entropy {} bits + checksum {} bits)",
            self.word_count(),
            self.entropy_bits(),
            self.checksum_bits()
        )
    }
}

impl From<MnemonicWordCount> for usize {
    fn from(count: MnemonicWordCount) -> Self {
        match count {
            MnemonicWordCount::Words12 => 12,
            MnemonicWordCount::Words15 => 15,
            MnemonicWordCount::Words18 => 18,
            MnemonicWordCount::Words21 => 21,
            MnemonicWordCount::Words24 => 24,
        }
    }
}

impl convert::TryFrom<usize> for MnemonicWordCount {
    type Error = Error;

    fn try_from(count: usize) -> Result<Self, Self::Error> {
        Self::from_word_count(count)
    }
}

impl MnemonicWordCount {
    /// Creates a [`MnemonicWordCount`] for a mnemonic phrase with the given word count.
    fn from_word_count(count: usize) -> Result<Self, Error> {
        Ok(match count {
            12 => Self::Words12,
            15 => Self::Words15,
            18 => Self::Words18,
            21 => Self::Words21,
            24 => Self::Words24,
            others => return Err(Error::BadWordCount(others)),
        })
    }

    /// Creates a [`MnemonicWordCount`] for a mnemonic phrase with the given entropy bits size.
    fn from_key_size(size: usize) -> Result<Self, Error> {
        Ok(match size {
            128 => Self::Words12,
            160 => Self::Words15,
            192 => Self::Words18,
            224 => Self::Words21,
            256 => Self::Words24,
            others => return Err(Error::BadEntropyBitCount(others)),
        })
    }

    /// Creates a [`MnemonicWordCount`] for an existing mnemonic phrase.
    pub fn from_phrase<P: AsRef<str>>(phrase: P) -> Result<Self, Error> {
        let word_count = phrase.as_ref().split_whitespace().count();
        Self::from_word_count(word_count)
    }

    /// Returns the number of words.
    pub const fn word_count(&self) -> usize {
        self.total_bits() / BITS_PER_WORD
    }

    /// Returns the number of entropy+checksum bits.
    pub const fn total_bits(&self) -> usize {
        self.entropy_bits() + self.checksum_bits() as usize
    }

    /// Returns the number of entropy bits.
    pub const fn entropy_bits(&self) -> usize {
        (*self as usize) >> ENTROPY_OFFSET
    }

    /// Returns the number of checksum bits.
    pub const fn checksum_bits(&self) -> u8 {
        (*self as usize) as u8
    }
}

// const MAX_WORD_COUNT: usize = MnemonicWordCount::Words24.word_count();
// const MAX_TOTAL_BITS_LEN: usize = MnemonicWordCount::Words24.total_bits();
// const MAX_ENTROPY_BITS_LEN: usize = MnemonicWordCount::Words24.entropy_bits();

/// A mnemonic representation.
#[derive(Clone, Debug, Ord, PartialOrd, Eq, PartialEq, Hash)]
pub struct Mnemonic {
    lang: Language,
    phrase: String,
}

impl fmt::Display for Mnemonic {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.phrase())
    }
}

impl str::FromStr for Mnemonic {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::from_phrase(s)
    }
}

impl AsRef<str> for Mnemonic {
    fn as_ref(&self) -> &str {
        self.phrase()
    }
}

impl From<Mnemonic> for String {
    fn from(mnemonic: Mnemonic) -> Self {
        mnemonic.phrase
    }
}

impl Mnemonic {
    /// Create a [`Mnemonic`] from an existing mnemonic phrase.
    ///
    /// The phrase supplied will be checked for word length and validated according to the checksum
    /// specified in BIP-0039.
    ///
    /// # Example
    ///
    /// ```
    /// /*
    /// use bip0039::{Mnemonic, Language};
    ///
    /// let phrase = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
    /// let mnemonic = Mnemonic::from_phrase(phrase).unwrap();
    /// assert_eq!(mnemonic.phrase(), phrase);
    /// assert_eq!(mnemonic.to_entropy(), vec![0x1a, 0x48, 0x6a, 0x5f, 0xbe, 0x53, 0x63, 0x99, 0x84, 0xcb, 0x64, 0xb0, 0x70, 0x75, 0x5f, 0x7b]);
    /// */
    /// ```
    pub fn from_phrase<P: AsRef<str>>(_phrase: P) -> Result<Self, Error> {
        todo!()
    }

    /// Creates a new English [`Mnemonic`] from the given entropy.
    ///
    /// # Example
    ///
    /// ```
    /// use bip0039::Mnemonic;
    ///
    /// let entropy = [0x1a, 0x48, 0x6a, 0x5f, 0xbe, 0x53, 0x63, 0x99, 0x84, 0xcb, 0x64, 0xb0, 0x70, 0x75, 0x5f, 0x7b];
    /// let mnemonic = Mnemonic::from_entropy(entropy).unwrap();
    /// assert_eq!(mnemonic.phrase(), "bottom drive obey lake curtain smoke basket hold race lonely fit walk");
    /// ```
    pub fn from_entropy<E: AsRef<[u8]>>(entropy: E) -> Result<Self, Error> {
        Self::from_entropy_in(Language::English, entropy)
    }

    /// Creates a new [`Mnemonic`] in the specified language from the given entropy.
    pub fn from_entropy_in<E: AsRef<[u8]>>(lang: Language, entropy: E) -> Result<Self, Error> {
        let entropy = entropy.as_ref();
        let word_count = MnemonicWordCount::from_key_size(entropy.len() * 8)?;

        let mut bits = vec![false; word_count.total_bits()];
        // an initial entropy of ENT bits is generated.
        for (idx, bit) in bits.iter_mut().take(word_count.entropy_bits()).enumerate() {
            *bit = (entropy[idx / 8] & left_bit_mask(idx)) > 0;
        }
        // a checksum is generated by taking the first `ENT/32` bits of its SHA256 hash.
        let checksum = Sha256::digest(&entropy)[0];
        // This checksum is appended to the end of the initial entropy.
        for (idx, bit) in bits
            .iter_mut()
            .skip(word_count.entropy_bits())
            .take(word_count.checksum_bits() as usize)
            .enumerate()
        {
            *bit = (checksum & left_bit_mask(idx)) > 0;
        }

        let mut words = Vec::with_capacity(word_count.word_count());
        for chunk in bits.as_slice().chunks(BITS_PER_WORD) {
            assert_eq!(chunk.len(), BITS_PER_WORD);
            let idx = bits11_to_index(chunk);
            words.push(lang.word_list()[idx]);
        }
        let phrase = words.join(" ");

        Ok(Self { lang, phrase })
    }

    /// Generate a new English [`Mnemonic`] in the specified word count.
    ///
    /// # Example
    ///
    /// ```
    /// use bip0039::{Mnemonic, MnemonicWordCount};
    ///
    /// let mnemonic = Mnemonic::generate(MnemonicWordCount::Words12);
    /// let phrase = mnemonic.phrase();
    /// ```
    #[cfg(feature = "rand")]
    pub fn generate(word_count: MnemonicWordCount) -> Self {
        Self::generate_in(Language::English, word_count)
    }

    /// Generate a new [`Mnemonic`] in the specified language and word count.
    ///
    /// # Example
    ///
    /// ```
    /// use bip0039::{Language, Mnemonic, MnemonicWordCount};
    ///
    /// let mnemonic = Mnemonic::generate_in(Language::English, MnemonicWordCount::Words12);
    /// let phrase = mnemonic.phrase();
    /// ```
    #[cfg(feature = "rand")]
    pub fn generate_in(lang: Language, word_count: MnemonicWordCount) -> Self {
        const MAX_ENTROPY_BITS_LEN: usize = MnemonicWordCount::Words24.entropy_bits();
        let mut entropy = [0u8; MAX_ENTROPY_BITS_LEN / 8];

        let mut rng = rand::thread_rng();
        rand::RngCore::fill_bytes(&mut rng, &mut entropy);

        let entropy_bytes = word_count.entropy_bits() / 8;
        Self::from_entropy_in(lang, &entropy[..entropy_bytes])
            .expect("valid entropy length won't fail to generate the mnemonic")
    }

    /// Generates the seed from the [`Mnemonic`] and the passphrase.
    /// If a passphrase is not present, an empty string "" is used instead.
    pub fn to_seed<P: AsRef<str>>(&self, passphrase: P) -> [u8; 64] {
        // use the PBKDF2 function with a mnemonic sentence (in UTF-8 NFKD) used as the password
        // and the string "mnemonic" + passphrase (again in UTF-8 NFKD) used as the salt.
        // The iteration count is set to 2048 and HMAC-SHA512 is used as the pseudo-random function.
        // The length of the derived key is 512 bits (= 64 bytes).
        const PBKDF2_ROUNDS: u32 = 2048;
        const PBKDF2_BYTES: usize = 64;

        let normalized_password = self.phrase();
        let salt = format!("mnemonic{}", passphrase.as_ref());
        let normalized_salt = salt.nfkd().to_string();

        let mut seed = [0u8; PBKDF2_BYTES];
        pbkdf2::pbkdf2::<Hmac<Sha512>>(
            normalized_password.as_bytes(),
            normalized_salt.as_bytes(),
            PBKDF2_ROUNDS,
            &mut seed,
        );
        seed
    }

    /// Returns the [`Language`] of the mnemonic.
    pub fn lang(&self) -> Language {
        self.lang
    }

    /// Returns the mnemonic phrase as a string slice.
    pub fn phrase(&self) -> &str {
        &self.phrase
    }
}

#[test]
fn test_mnemonic_word_count() {
    let mnemonic = MnemonicWordCount::Words12;
    assert_eq!(mnemonic.word_count(), 12);
    assert_eq!(mnemonic.total_bits(), 128 + 4);
    assert_eq!(mnemonic.entropy_bits(), 128);
    assert_eq!(mnemonic.checksum_bits(), 4);

    let mnemonic = MnemonicWordCount::Words15;
    assert_eq!(mnemonic.word_count(), 15);
    assert_eq!(mnemonic.total_bits(), 160 + 5);
    assert_eq!(mnemonic.entropy_bits(), 160);
    assert_eq!(mnemonic.checksum_bits(), 5);

    let mnemonic = MnemonicWordCount::Words18;
    assert_eq!(mnemonic.word_count(), 18);
    assert_eq!(mnemonic.total_bits(), 192 + 6);
    assert_eq!(mnemonic.entropy_bits(), 192);
    assert_eq!(mnemonic.checksum_bits(), 6);

    let mnemonic = MnemonicWordCount::Words21;
    assert_eq!(mnemonic.word_count(), 21);
    assert_eq!(mnemonic.total_bits(), 224 + 7);
    assert_eq!(mnemonic.entropy_bits(), 224);
    assert_eq!(mnemonic.checksum_bits(), 7);

    let mnemonic = MnemonicWordCount::Words24;
    assert_eq!(mnemonic.word_count(), 24);
    assert_eq!(mnemonic.total_bits(), 256 + 8);
    assert_eq!(mnemonic.entropy_bits(), 256);
    assert_eq!(mnemonic.checksum_bits(), 8);
}
